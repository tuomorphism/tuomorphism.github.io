---
import type { CollectionEntry } from 'astro:content';
import ProjectCard from './ProjectCard.astro';

interface Props {
  items: CollectionEntry<'projects'>[];
  previewCount?: number;
}
const { items, previewCount } = Astro.props as Props;

const sortedItems = [...items].sort((a, b) => {
  if (a.data.tier !== b.data.tier) return a.data.tier - b.data.tier;
  const bDate = (b.data.date || new Date()).getTime()
  const aDate = (a.data.date || new Date()).getTime()
  // Date comparison, newer first
  if (aDate != bDate) return bDate - aDate;
  return a.data.title.localeCompare(b.data.title);
});

const visibleItems = typeof previewCount === 'number'
  ? sortedItems.slice(0, previewCount)
  : sortedItems;
---

<!-- ProjectGrid.astro -->
<section
  id="projects"
  class="masonry-grid grid gap-6 sm:gap-7 lg:gap-8
         grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"
>
  {visibleItems.map((p) => (
    <article class="grid-item">
      <div class="grid-item-content">
        <ProjectCard project={p} />
      </div>
    </article>
  ))}
</section>

<script is:inline>
  // Masonry with CSS Grid row-span trick
  const grid = document.currentScript?.previousElementSibling;

  if (grid) {
    const gap = parseInt(getComputedStyle(grid).gap) || 0;
    const row = parseInt(getComputedStyle(grid).getPropertyValue('--masonry-row') || '8'); // px

    const size = (item) => {
      const content = item.querySelector('.grid-item-content') || item;
      const h = content.getBoundingClientRect().height;
      const span = Math.ceil((h + gap) / (row + gap));
      item.style.gridRowEnd = `span ${span}`;
    };

    const all = () => grid.querySelectorAll('.grid-item').forEach(size);

    const ro = new ResizeObserver(() => all());
    grid.querySelectorAll('.grid-item-content').forEach((el) => ro.observe(el));

    window.addEventListener('load', all);
    window.addEventListener('resize', all);
    all();
  }
</script>
