---
/* LevelSetCanvas.astro
 * Abstract layered level set animation using marching squares
 * Works in Astro + Tailwind, no dependencies
 * Place in /src/components and use:
 *    <LevelSetCanvas class="w-full h-96 rounded-2xl" />
 */
const { class: className = "w-full h-96 rounded-2xl" } = Astro.props;
---

<canvas class={className}></canvas>

<script>
  const canvas = document.currentScript.previousElementSibling;
  const ctx = canvas.getContext("2d");
  let width, height;

  // Responsive resize
  function resize() {
    width = canvas.clientWidth;
    height = canvas.clientHeight;
    canvas.width = width;
    canvas.height = height;
  }
  window.addEventListener("resize", resize);
  resize();

  // Dark/light mode palettes
  function getPalette() {
    const dark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    return dark
      ? ["#8be9fd", "#bd93f9", "#ffb86c", "#50fa7b", "#ff79c6"] // bright but tasteful
      : ["#7bdff6", "#9b8cf2", "#ffd166", "#9be7a6", "#f29fb5"]; // softer light mode
  }
  let palette = getPalette();
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
    palette = getPalette();
  });

  // Scalar field parameters
  const waves = [
    { kx: 2.1, ky: 1.5, amp: 0.7, speed: 0.08 },
    { kx: -1.3, ky: 2.4, amp: 0.6, speed: 0.05 },
    { kx: 2.9, ky: -1.7, amp: 0.5, speed: 0.07 },
  ];
  const levels = [-0.5, -0.25, 0, 0.25, 0.5]; // iso-values

  // Marching squares
  function field(x, y, t) {
    let val = 0;
    for (const w of waves) {
      val += w.amp * Math.sin(w.kx * x + w.ky * y + w.speed * t);
    }
    return val;
  }
  function marchingSquares(t) {
    const step = 6; // grid spacing
    for (let li = 0; li < levels.length; li++) {
      ctx.strokeStyle = palette[li % palette.length];
      ctx.beginPath();
      const iso = levels[li];
      for (let gx = 0; gx < width; gx += step) {
        for (let gy = 0; gy < height; gy += step) {
          const x0 = gx, y0 = gy;
          const x1 = gx + step, y1 = gy + step;
          const f00 = field(x0 / 60, y0 / 60, t);
          const f10 = field(x1 / 60, y0 / 60, t);
          const f11 = field(x1 / 60, y1 / 60, t);
          const f01 = field(x0 / 60, y1 / 60, t);
          let state = 0;
          if (f00 > iso) state |= 1;
          if (f10 > iso) state |= 2;
          if (f11 > iso) state |= 4;
          if (f01 > iso) state |= 8;
          if (state === 0 || state === 15) continue;

          const interp = (a, b, fa, fb) => a + (iso - fa) * (b - a) / (fb - fa);

          const edges = [];
          if (state & 1 && !(state & 2))
            edges.push([interp(x0, x1, f00, f10), y0]);
          else if (!(state & 1) && (state & 2))
            edges.push([interp(x0, x1, f00, f10), y0]);

          if (state & 2 && !(state & 4))
            edges.push([x1, interp(y0, y1, f10, f11)]);
          else if (!(state & 2) && (state & 4))
            edges.push([x1, interp(y0, y1, f10, f11)]);

          if (state & 4 && !(state & 8))
            edges.push([interp(x0, x1, f01, f11), y1]);
          else if (!(state & 4) && (state & 8))
            edges.push([interp(x0, x1, f01, f11), y1]);

          if (state & 8 && !(state & 1))
            edges.push([x0, interp(y0, y1, f00, f01)]);
          else if (!(state & 8) && (state & 1))
            edges.push([x0, interp(y0, y1, f00, f01)]);

          if (edges.length === 2) {
            ctx.moveTo(edges[0][0], edges[0][1]);
            ctx.lineTo(edges[1][0], edges[1][1]);
          }
        }
      }
      ctx.stroke();
    }
  }

  // Animation loop â€” small movement
  function animate(time) {
    ctx.clearRect(0, 0, width, height);
    marchingSquares(time * 0.001); // time in seconds
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
</script>
